"""
Exploitation Agent for PwnAI.

This agent is responsible for developing exploits based on the
vulnerabilities identified by the Reversing and Debugging Agents.
"""

import json
import os
import re
import subprocess
import sys
import tempfile
from pathlib import Path
from typing import Any, Dict, List, Optional, Tuple, Union

import pwn
from pwn import *  # Import all pwntools functionality

from pwnai.agents.base_agent import BaseAgent
from pwnai.tools.gdb import GDBWrapper
from pwnai.utils.llm_service import LLMService


class ExploitationAgent(BaseAgent):
    """
    Agent for developing exploits.
    
    This agent uses information from the Reversing and Debugging Agents
    to develop working exploits for identified vulnerabilities.
    """
    
    def __init__(
        self,
        state: Dict[str, Any],
        binary_path: Path,
        output_dir: Path,
        llm_config: Optional[Dict[str, Any]] = None,
        remote_host: Optional[str] = None,
        remote_port: Optional[int] = None,
    ):
        """
        Initialize the Exploitation Agent.
        
        Args:
            state: Shared state dictionary for inter-agent communication
            binary_path: Path to the target binary
            output_dir: Directory to store output files
            llm_config: Configuration for the LLM
            remote_host: Remote host for the challenge (if applicable)
            remote_port: Remote port for the challenge (if applicable)
        """
        super().__init__(state, binary_path, output_dir, llm_config)
        
        self.remote_host = remote_host
        self.remote_port = remote_port
        
        # Initialize GDB wrapper for testing exploits
        self.gdb = GDBWrapper(binary_path)
        
        # Set architecture for pwntools context
        if "architecture" in self.state:
            arch_info = self.state["architecture"]
            if arch_info.get("arch") == "x86" and arch_info.get("bits") == 64:
                context.arch = "amd64"
            elif arch_info.get("arch") == "x86" and arch_info.get("bits") == 32:
                context.arch = "i386"
            elif arch_info.get("arch") == "arm" and arch_info.get("bits") == 64:
                context.arch = "aarch64"
            elif arch_info.get("arch") == "arm":
                context.arch = "arm"
        
        # Set binary for pwntools context
        context.binary = self.binary_path
        
        # Initialize LLM service
        llm_system_prompt = """
        You are a binary exploitation expert tasked with developing exploits for CTF challenges.
        You have deep knowledge of exploitation techniques including buffer overflows, format string attacks,
        ROP chains, return-to-libc, and other memory corruption techniques.
        
        Based on the information provided about the target binary (vulnerabilities, memory layout,
        security features, etc.), your task is to develop a working exploit. You should:
        
        1. Select the appropriate exploitation technique based on the vulnerability and security features
        2. Craft a precise payload with the correct offsets, addresses, and ROP gadgets
        3. Utilize pwntools functions to create and test the exploit
        4. Generate a Python script that implements the exploit
        
        Your exploit script should be well-commented, explaining each step of the exploitation process.
        The script should work both locally and against a remote target when available.
        """
        
        self.llm = LLMService(
            system_prompt=llm_system_prompt,
            **(llm_config or {})
        )
    
    def run(self) -> Dict[str, Any]:
        """
        Develop an exploit for the binary.
        
        Returns:
            Updated state dictionary with exploit information
        """
        self.logger.info("Starting exploit development")
        
        # Check if we have vulnerability information
        vulnerabilities = self.get_from_state("vulnerabilities", [])
        if not vulnerabilities:
            self.logger.warning("No vulnerabilities found in state, exploitation may be limited")
        
        # Get debugging results
        debug_results = self.get_from_state("debug_results", {})
        
        # Plan the exploitation strategy
        exploitation_plan = self._plan_exploitation(vulnerabilities, debug_results)
        
        # Save the plan to disk
        plan_path = self.output_dir / "exploitation_plan.txt"
        with open(plan_path, "w") as f:
            f.write(exploitation_plan)
        
        self.logger.info(f"Saved exploitation plan to {plan_path}")
        
        # Develop the exploit based on the plan
        exploit_script, exploit_summary = self._develop_exploit(exploitation_plan)
        
        # Save the exploit script to disk
        script_path = self.output_dir / "exploit.py"
        with open(script_path, "w") as f:
            f.write(exploit_script)
        
        self.logger.info(f"Saved exploit script to {script_path}")
        
        # Make the script executable
        os.chmod(script_path, 0o755)
        
        # Try to test the exploit locally
        success, output = self._test_exploit(script_path)
        
        # Save the test results to disk
        test_path = self.output_dir / "exploit_test_results.txt"
        with open(test_path, "w") as f:
            f.write(f"Success: {success}\n\n")
            f.write(f"Output:\n{output}")
        
        self.logger.info(f"Saved exploit test results to {test_path}")
        
        # Update state with exploit information
        self.update_state({
            "exploitation_plan": exploitation_plan,
            "exploit_script": exploit_script,
            "exploit_summary": exploit_summary,
            "exploit_test_success": success,
            "exploit_test_output": output,
        })
        
        # Log result
        if success:
            self.log_result("Successfully developed and tested exploit")
        else:
            self.log_result("Developed exploit but testing was unsuccessful")
        
        return self.state
    
    def _plan_exploitation(
        self,
        vulnerabilities: List[Dict[str, Any]],
        debug_results: Dict[str, Any],
    ) -> str:
        """
        Plan the exploitation strategy based on identified vulnerabilities.
        
        Args:
            vulnerabilities: List of vulnerability dictionaries
            debug_results: Results from debugging and dynamic analysis
            
        Returns:
            Exploitation plan as text
        """
        # Extract security features
        security_features = self.get_from_state("security_features", {})
        if not security_features and "security_features" in debug_results:
            security_features = debug_results["security_features"]
        
        # Extract key debugging information
        overflow_offset = debug_results.get("overflow_offset")
        overflow_message = debug_results.get("overflow_message", "")
        leaked_addresses = debug_results.get("leaked_addresses", [])
        libc_base = debug_results.get("libc_base")
        crash_analysis = debug_results.get("crash_analysis", {})
        rop_gadgets = debug_results.get("rop_gadgets", [])
        
        # Create a detailed prompt for the LLM
        prompt = """
        Please help me plan an exploitation strategy for a binary with the following characteristics:
        
        ## VULNERABILITIES
        {vulnerabilities}
        
        ## SECURITY FEATURES
        {security_features}
        
        ## DEBUGGING INFORMATION
        - Buffer Overflow Offset: {overflow_offset}
        - Controlled PC (EIP/RIP): {controlled_pc}
        - Leaked Addresses: {leaked_addresses}
        - Libc Base: {libc_base}
        - Architecture: {arch} {bits}-bit
        
        ## AVAILABLE ROP GADGETS
        {rop_gadgets}
        
        Based on this information, please outline a detailed exploitation strategy including:
        1. The vulnerability to exploit
        2. The technique to use (stack overflow, ROP, ret2libc, format string, etc.)
        3. A step-by-step plan for developing the exploit
        4. Any specific addresses, offsets, or gadgets that will be needed
        
        Consider the security features of the binary and provide a strategy that bypasses them.
        """
        
        # Format vulnerabilities for the prompt
        vuln_text = ""
        for i, vuln in enumerate(vulnerabilities):
            vuln_text += f"{i+1}. Type: {vuln.get('type', 'unknown')}\n"
            if "location" in vuln:
                vuln_text += f"   Location: {vuln['location']}\n"
            if "description" in vuln:
                vuln_text += f"   Description: {vuln['description']}\n"
            if "exploitation" in vuln:
                vuln_text += f"   Exploitation: {vuln['exploitation']}\n"
        
        if not vuln_text:
            vuln_text = "No specific vulnerabilities identified by static analysis."
        
        # Format security features
        security_text = ""
        for k, v in security_features.items():
            security_text += f"- {k.upper()}: {v}\n"
        
        if not security_text:
            security_text = "No security feature information available."
        
        # Format leaked addresses
        leaked_text = ""
        for i, leak in enumerate(leaked_addresses[:5]):  # Limit to first 5
            leaked_text += f"- {leak.get('address')} (via {leak.get('payload', 'unknown')})\n"
        
        if len(leaked_addresses) > 5:
            leaked_text += f"[...and {len(leaked_addresses) - 5} more...]\n"
        
        if not leaked_text:
            leaked_text = "None"
        
        # Format ROP gadgets (sample of useful ones)
        rop_text = ""
        gadget_count = 0
        important_patterns = ["pop rdi", "pop rsi", "pop rdx", "pop rax", "syscall",
                              "pop ebp", "pop esp", "pop ebx", "int 0x80"]
        
        for gadget in rop_gadgets:
            instruction = gadget.get("instruction", "")
            if any(pattern in instruction for pattern in important_patterns):
                rop_text += f"- {instruction} @ {gadget.get('address')}\n"
                gadget_count += 1
                if gadget_count >= 10:  # Limit to 10 gadgets
                    break
        
        if gadget_count < len(rop_gadgets):
            rop_text += f"[...and {len(rop_gadgets) - gadget_count} more...]\n"
        
        if not rop_text:
            rop_text = "No ROP gadgets found or available."
        
        # Format architecture info
        arch_info = self.get_from_state("architecture", {})
        arch = arch_info.get("arch", "unknown")
        bits = arch_info.get("bits", 0)
        
        # Format the prompt
        controlled_pc = "Yes" if crash_analysis.get("controlled_pc", False) else "No"
        libc_base_str = hex(libc_base) if libc_base else "Not found"
        
        formatted_prompt = prompt.format(
            vulnerabilities=vuln_text,
            security_features=security_text,
            overflow_offset=overflow_offset if overflow_offset is not None else "Not found",
            controlled_pc=controlled_pc,
            leaked_addresses=leaked_text,
            libc_base=libc_base_str,
            arch=arch,
            bits=bits,
            rop_gadgets=rop_text,
        )
        
        # Call LLM
        self.logger.debug("Sending exploitation planning request to LLM")
        response = self.llm.call(formatted_prompt)
        
        return response
    
    def _develop_exploit(self, exploitation_plan: str) -> Tuple[str, str]:
        """
        Develop the actual exploit code based on the exploitation plan.
        
        Args:
            exploitation_plan: The exploitation strategy from the planner
            
        Returns:
            Tuple of (exploit script, summary of the exploit)
        """
        # Create a prompt for the LLM to generate the exploit code
        prompt = """
        Based on the exploitation plan below, please write a complete Python exploit script using Pwntools.
        The script should be well-commented and include all necessary imports and setup.
        
        ## EXPLOITATION PLAN
        {plan}
        
        ## BINARY INFORMATION
        - Path: {binary_path}
        - Architecture: {arch} {bits}-bit
        
        ## DEBUGGING INFORMATION
        {debug_info}
        
        ## REMOTE TARGET
        - Host: {remote_host}
        - Port: {remote_port}
        
        Please generate a complete exploit script that:
        1. Works both locally and against the remote target (if provided)
        2. Uses Pwntools for all interactions and payload creation
        3. Includes clear comments explaining each step
        4. Has proper error handling
        5. Prints the flag or confirms successful exploitation
        
        The script should be ready to run without modification.
        """
        
        # Extract architecture information
        arch_info = self.get_from_state("architecture", {})
        arch = arch_info.get("arch", "unknown")
        bits = arch_info.get("bits", 0)
        
        # Format debugging information
        debug_results = self.get_from_state("debug_results", {})
        debug_info = ""
        
        if "overflow_offset" in debug_results and debug_results["overflow_offset"] is not None:
            debug_info += f"- Buffer Overflow Offset: {debug_results['overflow_offset']} bytes\n"
        
        if "libc_base" in debug_results and debug_results["libc_base"]:
            debug_info += f"- Libc Base Address: {hex(debug_results['libc_base'])}\n"
        
        crash_analysis = debug_results.get("crash_analysis", {})
        if crash_analysis.get("controlled_pc", False):
            debug_info += f"- Program Counter (EIP/RIP) controlled at offset: {crash_analysis.get('pc_offset')}\n"
        
        if not debug_info:
            debug_info = "No specific debugging information available."
        
        # Format remote target info
        remote_host = self.remote_host or "None"
        remote_port = str(self.remote_port) if self.remote_port else "None"
        
        # Format the prompt
        formatted_prompt = prompt.format(
            plan=exploitation_plan,
            binary_path=str(self.binary_path),
            arch=arch,
            bits=bits,
            debug_info=debug_info,
            remote_host=remote_host,
            remote_port=remote_port,
        )
        
        # Call LLM to generate the exploit
        self.logger.debug("Requesting exploit script generation from LLM")
        response = self.llm.call(formatted_prompt, max_tokens=4096)
        
        # Extract the Python script from the response
        script = self._extract_code(response)
        
        # Create a summary of the exploit
        summary_prompt = """
        Please provide a concise summary (2-3 paragraphs) of the exploit script.
        Explain the vulnerability being exploited, the technique used, and how it works.
        
        ## EXPLOIT SCRIPT
        ```python
        {script}
        ```
        """
        
        formatted_summary_prompt = summary_prompt.format(script=script)
        summary = self.llm.call(formatted_summary_prompt, max_tokens=1024)
        
        return script, summary
    
    def _extract_code(self, response: str) -> str:
        """
        Extract Python code from an LLM response.
        
        Args:
            response: The LLM response text
            
        Returns:
            The extracted Python code
        """
        # Look for Python code blocks
        python_blocks = re.findall(r'```(?:python)?\s*\n(.*?)```', response, re.DOTALL)
        
        if python_blocks:
            # Use the longest code block (most likely the full script)
            return max(python_blocks, key=len)
        
        # If no code blocks found, try to extract all the script
        # by looking for common Python syntax
        potential_script = ""
        in_script = False
        
        for line in response.split('\n'):
            if not in_script and (line.startswith('from ') or line.startswith('import ') or 
                                  line.startswith('#!/usr/bin/env python')):
                in_script = True
                potential_script += line + '\n'
            elif in_script:
                potential_script += line + '\n'
        
        if potential_script:
            return potential_script
        
        # As a fallback, just return the entire response
        # (might need cleanup before execution)
        return response
    
    def _test_exploit(self, script_path: Path) -> Tuple[bool, str]:
        """
        Test the exploit script locally.
        
        Args:
            script_path: Path to the exploit script
            
        Returns:
            Tuple of (success boolean, output text)
        """
        self.logger.info("Testing exploit script locally")
        
        try:
            # Run the exploit script in a subprocess
            env = os.environ.copy()
            env["PWNLIB_NOTERM"] = "true"  # Disable terminal features that might cause issues
            
            cmd = [sys.executable, str(script_path)]
            if self.remote_host and self.remote_port:
                # If testing locally, add --local flag if script supports it
                cmd.append("--local")
            
            proc = subprocess.run(
                cmd,
                env=env,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                timeout=30,  # Timeout after 30 seconds
                text=True,
            )
            
            output = "STDOUT:\n" + proc.stdout + "\n\nSTDERR:\n" + proc.stderr
            
            # Check for indicators of success
            success_indicators = ["flag{", "CTF{", "pwned", "shell", "success"]
            success = proc.returncode == 0 and any(indicator.lower() in output.lower() 
                                                 for indicator in success_indicators)
            
            if success:
                self.logger.info("Exploit appears to be successful")
            else:
                self.logger.warning(f"Exploit test returned code {proc.returncode}, may not be successful")
            
            return success, output
        
        except subprocess.TimeoutExpired:
            self.logger.warning("Exploit test timed out")
            return False, "Timeout: Exploit test took too long to complete"
        
        except Exception as e:
            self.logger.error(f"Error testing exploit: {str(e)}")
            return False, f"Error: {str(e)}" 