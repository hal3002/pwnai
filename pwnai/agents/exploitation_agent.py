"""
Exploitation Agent for PwnAI.

This agent is responsible for developing an exploit based on the vulnerabilities 
identified by the other agents.
"""

import json
import os
import re
import subprocess
import sys
import tempfile
import time
from pathlib import Path
from typing import Any, Dict, List, Optional, Tuple, Union

import pwn
from pwn import *  # Import all pwntools functionality

from pwnai.agents.base_agent import BaseAgent
from pwnai.tools.gdb import GDBWrapper
from pwnai.tools.radare2 import Radare2
from pwnai.utils.llm_service import LLMService


class ExploitationAgent(BaseAgent):
    """
    Agent for developing exploits.
    
    This agent uses information from the Reversing and Debugging Agents
    to develop working exploits for identified vulnerabilities.
    """
    
    def __init__(
        self,
        state: Dict[str, Any],
        binary_path: Path,
        output_dir: Path,
        llm_config: Optional[Dict[str, Any]] = None,
        llm_service: Optional[LLMService] = None,
        remote_host: Optional[str] = None,
        remote_port: Optional[int] = None,
    ):
        """
        Initialize the Exploitation Agent.
        
        Args:
            state: Shared state dictionary for inter-agent communication
            binary_path: Path to the target binary
            output_dir: Directory to store output files
            llm_config: Configuration for the LLM
            llm_service: Optional shared LLM service instance
            remote_host: Remote host for the challenge (if applicable)
            remote_port: Remote port for the challenge (if applicable)
        """
        super().__init__(state, binary_path, output_dir, llm_config, llm_service)
        
        self.remote_host = remote_host
        self.remote_port = remote_port
        
        # Initialize binary analyzer
        self.binary_analyzer = Radare2(str(binary_path))
        
        # Initialize GDB wrapper for testing exploits
        self.gdb = GDBWrapper(binary_path)
        
        # Set architecture for pwntools context
        if "architecture" in self.state:
            arch_info = self.state["architecture"]
            if arch_info.get("arch") == "x86" and arch_info.get("bits") == 64:
                context.arch = "amd64"
            elif arch_info.get("arch") == "x86" and arch_info.get("bits") == 32:
                context.arch = "i386"
            elif arch_info.get("arch") == "arm" and arch_info.get("bits") == 64:
                context.arch = "aarch64"
            elif arch_info.get("arch") == "arm":
                context.arch = "arm"
        
        # Set binary for pwntools context
        context.binary = self.binary_path
        
        # Initialize LLM service if not provided
        if self.llm_service is None:
            llm_system_prompt = """
            You are a binary exploitation expert tasked with developing exploits for CTF challenges.
            You have deep knowledge of exploitation techniques including buffer overflows, format string attacks,
            ROP chains, return-to-libc, and other memory corruption techniques.
            
            Based on the information provided about the target binary (vulnerabilities, memory layout,
            security features, etc.), your task is to develop a working exploit. You should:
            
            1. Select the appropriate exploitation technique based on the vulnerability and security features
            2. Craft a precise payload with the correct offsets, addresses, and ROP gadgets
            3. Utilize pwntools functions to create and test the exploit
            4. Generate a Python script that implements the exploit
            
            CRITICAL REQUIREMENTS FOR RELIABLE EXPLOITS:
            
            1. NEVER use dummy or placeholder addresses in final exploits (like 0x41414141, 0xdeadbeef, 0xffffd0f0, etc.)
            
            2. NEVER attempt to jump/return directly to the stack using hardcoded addresses - this is unreliable
               even when NX is disabled. Stack addresses change between runs and environments.
               
            3. ALWAYS use reliable techniques to reach shellcode:
               - Find a "jmp esp", "call esp", or equivalent gadget in the binary or libraries
               - Use return-oriented programming (ROP) with gadgets from the binary or libraries
               - Leverage existing functions in the binary or libraries (system, execve)
               
            4. For stack-based exploits:
               - Use pattern_create/pattern_offset to find the exact buffer offset
               - Use a "jmp esp" gadget from the binary/library (search for it with ROPgadget)
               - Place the shellcode after the return address in the buffer
               - Return to the "jmp esp" gadget, which will execute the shellcode that follows
            
            5. When you need a gadget, specify the exact pattern (like "jmp esp" or "pop rdi; ret") that
               you need. If a gadget isn't available, look for alternative techniques.
               
            Your exploit script should be well-commented, explaining each step of the exploitation process.
            The script should work both locally and against a remote target when available.
            """
            
            self.llm = LLMService(
                system_prompt=llm_system_prompt,
                **(llm_config or {})
            )
        else:
            self.llm = self.llm_service
    
    def run(self, remote: bool = False) -> Dict[str, Any]:
        """
        Run the exploitation agent to develop and test an exploit.
        
        Args:
            remote: If True, attempt to exploit a remote target
        
        Returns:
            Updated state dictionary with the exploitation results
        """
        self.logger.info("Starting exploitation process")
        
        # If targeting a remote server
        if remote:
            self.logger.info(f"Targeting remote server: {self.state.get('remote_target')}")
            return self._run_remote_exploit()
        
        # Extract vulnerabilities identified in previous stages
        vulnerabilities = self.state.get("vulnerabilities", [])
        
        # Extract debugging results
        debug_results = {}
        for key in ["overflow_offset", "gadgets", "leaked_addresses", "shellcode_file"]:
            if key in self.state:
                debug_results[key] = self.state[key]
        
        # 1. Plan the exploitation
        self.logger.debug("Planning exploitation approach")
        exploitation_plan = self._create_exploitation_plan()
        
        # Track our exploit attempts for iterative refinement
        MAX_ITERATIONS = 3  # Maximum number of refinement iterations
        iteration = 0
        success = False
        result_data = {}
        user_confirmed = False
        
        # Iterative exploit development process
        while iteration < MAX_ITERATIONS and not (success and user_confirmed):
            iteration += 1
            self.logger.info(f"Starting exploit development iteration {iteration}/{MAX_ITERATIONS}")
        
        # 2. Develop the exploit
            if iteration == 1:
                self.logger.info("Developing initial exploit")
                exploit_code, exploit_description = self._develop_exploit(exploitation_plan)
            else:
                self.logger.info(f"Refining exploit based on previous feedback (iteration {iteration})")
                exploit_code, exploit_description = self._refine_exploit(exploitation_plan, failure_data)
            
            # 3. Test the exploit
            self.logger.info("Testing exploit against local binary")
            success, result, output = self._test_exploit()
            
            if success:
                self.logger.info("Exploit execution appears successful! Getting user confirmation...")
                
                # Display test results to the user
                print("\n" + "="*80)
                print("EXPLOIT TEST RESULTS")
                print("="*80)
                print(f"Exploit appears to be successful!")
                
                # Show a summary of the exploit code
                print("\nEXPLOIT CODE SUMMARY:")
                print("-"*80)
                code_lines = exploit_code.split('\n')
                if len(code_lines) > 20:
                    # Show important parts of the code (first 10 lines and the exploit function)
                    print('\n'.join(code_lines[:10]))
                    print("\n... [code truncated] ...\n")
                    
                    # Try to find and show the exploit function's core logic
                    exploit_func_start = -1
                    exploit_func_end = -1
                    for i, line in enumerate(code_lines):
                        if "def exploit(" in line:
                            exploit_func_start = i
                        elif exploit_func_start >= 0 and line.strip() == "":
                            if "def " in code_lines[i+1] if i+1 < len(code_lines) else False:
                                exploit_func_end = i
                                break
                    
                    if exploit_func_start >= 0:
                        end_idx = exploit_func_end if exploit_func_end > 0 else min(exploit_func_start + 15, len(code_lines))
                        print('\n'.join(code_lines[exploit_func_start:end_idx]))
                        print("...")
                else:
                    # If code is short, show it all
                    print(exploit_code)
                
                print("\nTest output summary:")
                
                # Show a summary of the output (limit to avoid overwhelming)
                output_lines = output.split('\n')
                if len(output_lines) > 20:
                    # Show the first 10 and last 10 lines
                    print('\n'.join(output_lines[:10]))
                    print(f"\n... [truncated {len(output_lines) - 20} lines] ...\n")
                    print('\n'.join(output_lines[-10:]))
                else:
                    # If output is short, show it all
                    print(output)
                
                # Ask user to confirm success
                while True:
                    confirmation = input("\nIs the exploit actually successful? [Y]es/[N]o/[V]iew full output/[C]ode/[D]ebug in GDB: ").strip().lower()
                    
                    if confirmation in ['y', 'yes']:
                        user_confirmed = True
                        print("Success confirmed by user.")
                        
                        # Optional: Ask for any additional feedback for refinement
                        additional_feedback = input("Any additional feedback to improve the exploit? (press Enter to skip): ").strip()
                        if additional_feedback:
                            print("Thank you for the feedback. It will be incorporated in future refinements.")
                        
                        result_data = result
                        if additional_feedback:
                            result_data["user_feedback"] = additional_feedback
                        break
                    elif confirmation in ['n', 'no']:
                        user_confirmed = False
                        success = False
                        print("Continuing with exploit refinement based on your feedback.")
                        
                        # Get specific feedback on why it failed
                        failure_reason = input("Please explain why the exploit failed: ").strip()
                        
                        # Collect failure data
                        failure_data = {
                            "output": output,
                            "iteration": iteration,
                            "exploit_code": exploit_code,
                            "user_feedback": failure_reason
                        }
                        break
                    elif confirmation in ['v', 'view']:
                        # Show full output
                        print("\nFULL TEST OUTPUT:")
                        print("-"*80)
                        print(output)
                        print("-"*80)
                    elif confirmation in ['c', 'code']:
                        # Show full exploit code
                        print("\nFULL EXPLOIT CODE:")
                        print("-"*80)
                        print(exploit_code)
                        print("-"*80)
                    elif confirmation in ['d', 'debug']:
                        # Debug in GDB
                        debug_insights = self._debug_crash_in_gdb()
                        if debug_insights:
                            if user_confirmed:
                                additional_feedback = debug_insights
                                print("Debugging insights will be incorporated into the exploit.")
                            else:
                                user_feedback = debug_insights
                                print("Debugging insights will be incorporated into the next exploitation attempt.")
                        break
                    else:
                        print("Invalid response. Please enter 'Y', 'N', 'V', 'C', or 'D'.")
                
                if user_confirmed:
                    break
            else:
                self.logger.warning(f"Exploit failed on iteration {iteration}")
                
                # Display failure information to user
                print("\n" + "="*80)
                print("EXPLOIT TEST RESULTS")
                print("="*80)
                print(f"Exploit execution failed!")
                
                # Show a summary of the exploit code
                print("\nEXPLOIT CODE SUMMARY:")
                print("-"*80)
                code_lines = exploit_code.split('\n')
                if len(code_lines) > 20:
                    # Show important parts of the code (first 10 lines and the exploit function)
                    print('\n'.join(code_lines[:10]))
                    print("\n... [code truncated] ...\n")
                    
                    # Try to find and show the exploit function's core logic
                    exploit_func_start = -1
                    exploit_func_end = -1
                    for i, line in enumerate(code_lines):
                        if "def exploit(" in line:
                            exploit_func_start = i
                        elif exploit_func_start >= 0 and line.strip() == "":
                            if "def " in code_lines[i+1] if i+1 < len(code_lines) else False:
                                exploit_func_end = i
                                break
                    
                    if exploit_func_start >= 0:
                        end_idx = exploit_func_end if exploit_func_end > 0 else min(exploit_func_start + 15, len(code_lines))
                        print('\n'.join(code_lines[exploit_func_start:end_idx]))
                        print("...")
                else:
                    # If code is short, show it all
                    print(exploit_code)
                
                print("\nTest output summary:")
                
                # Show a summary of the output
                output_lines = output.split('\n')
                if len(output_lines) > 20:
                    # Show the first 10 and last 10 lines
                    print('\n'.join(output_lines[:10]))
                    print(f"\n... [truncated {len(output_lines) - 20} lines] ...\n")
                    print('\n'.join(output_lines[-10:]))
                else:
                    # If output is short, show it all
                    print(output)
                
                # Allow user to view full output and provide feedback
                while True:
                    response = input("\nWould you like to provide feedback on this failure? [Y]es/[N]o/[V]iew full output/[C]ode/[D]ebug in GDB: ").strip().lower()
                    
                    if response in ['y', 'yes']:
                        user_feedback = input("Please provide insights about the exploit failure: ").strip()
                        if user_feedback:
                            print("Thank you! Your feedback will be incorporated into the next exploitation attempt.")
                        break
                    elif response in ['n', 'no']:
                        user_feedback = ""
                        print("Continuing with automated exploit refinement.")
                        break
                    elif response in ['v', 'view']:
                        # Show full output
                        print("\nFULL TEST OUTPUT:")
                        print("-"*80)
                        print(output)
                        print("-"*80)
                    elif response in ['c', 'code']:
                        # Show full exploit code
                        print("\nFULL EXPLOIT CODE:")
                        print("-"*80)
                        print(exploit_code)
                        print("-"*80)
                    elif response in ['d', 'debug']:
                        # Debug the crash in GDB
                        debug_insights = self._debug_crash_in_gdb()
                        if debug_insights:
                            user_feedback = debug_insights
                            print("Debugging insights will be incorporated into the next exploitation attempt.")
                        break
                    else:
                        print("Invalid response. Please enter 'Y', 'N', 'V', 'C', or 'D'.")
                
                # Collect failure data
                failure_data = {
                    "output": output,
                    "iteration": iteration,
                    "exploit_code": exploit_code
                }
                
                # Add user feedback if provided
                if 'user_feedback' in locals() and user_feedback:
                    failure_data["user_feedback"] = user_feedback
                
                # Analyze the failure
                failure_analysis = self._analyze_failure(failure_data)
                
                # Log the failure analysis
                self.logger.info(f"Failure analysis: {failure_analysis.get('summary', 'Unknown error')}")
                
                # Update the exploitation plan with the failure insights
                exploitation_plan = self._update_exploitation_plan(exploitation_plan, failure_analysis)
                
                # Save the improved plan
                plan_path = self.output_dir / f"exploitation_plan_iteration_{iteration+1}.txt"
                with open(plan_path, "w") as f:
                    f.write(exploitation_plan)
        
        # If all iterations failed or user never confirmed success
        if not (success and user_confirmed):
            self.logger.error(f"Failed to develop a working exploit after {MAX_ITERATIONS} iterations")
            result_data = {"exploitable": False, "reason": "Maximum iterations reached without confirmed success"}
        
        # Return the results as state updates
        results = {
            "exploit_code": exploit_code,
            "exploit_description": exploit_description,
            "exploitation_plan": exploitation_plan,
            "exploit_successful": success and user_confirmed,
            "user_confirmed": user_confirmed
        }
        results.update(result_data)
        
        self.logger.info(f"Exploitation completed (success: {success and user_confirmed})")
        return results
    
    def _create_exploitation_plan(self) -> str:
        """
        Create an exploitation plan based on the findings.
            
        Returns:
            Exploitation plan as a string
        """
        # Get relevant information from the state
        vuln_type = self.state.get("vulnerability_type", "unknown")
        vulnerabilities = self.state.get("vulnerabilities", [])
        
        # Security features
        security_features = self.state.get("security_features", {})
        
        # Debugging results
        overflow_offset = self.state.get("overflow_offset")
        gadgets = self.state.get("gadgets", [])
        leaked_addresses = self.state.get("leaked_addresses", {})
        
        # Build a prompt for the LLM
        prompt = f"""
        I need to develop an exploitation plan for a binary with a {vuln_type} vulnerability.
        
        ## Security Features
        - NX (No-Execute): {security_features.get('nx', 'unknown')}
        - Stack Canary: {security_features.get('canary', 'unknown')}
        - PIE (Position Independent Executable): {security_features.get('pie', 'unknown')}
        - RELRO: {security_features.get('relro', 'unknown')}
        
        ## Debugging Results
        - Overflow Offset: {overflow_offset}
        - Number of Gadgets: {len(gadgets)}
        - Leaked Addresses: {leaked_addresses}
        
        ## Vulnerabilities
        {self._format_vulnerabilities(vulnerabilities)}
        
        Based on this information, create a detailed exploitation plan. 
        Include the specific techniques you'll use, any gadgets needed, 
        and how you'll bypass security features.
        
        Provide instructions for developing the exploit that would achieve 
        the goal of the challenge, which typically involves getting a shell, 
        reading a flag file, or triggering a specific condition.
        
        """
        
        # Incorporate user feedback if available
        prompt = self.incorporate_feedback(prompt)
        
        # Incorporate source file if available
        prompt = self.incorporate_source(prompt)
        
        # If we have specific vulnerabilities, incorporate the feedback from the first one
        if vulnerabilities and isinstance(vulnerabilities[0], dict):
            prompt = self.incorporate_vulnerability_feedback(prompt, vulnerabilities[0])
        
        # Call LLM
        self.logger.info("Creating exploitation plan...")
        plan = self.llm.call(prompt)
        
        # Save plan to file
        plan_path = self.output_dir / "exploitation_plan.txt"
        with open(plan_path, "w") as f:
            f.write(plan)
        
        self.logger.info(f"Saved exploitation plan to {plan_path}")
        
        return plan
    
    def _format_vulnerabilities(self, vulnerabilities: List[Dict[str, Any]]) -> str:
        """
        Format vulnerabilities for inclusion in prompts.
        
        Args:
            vulnerabilities: List of vulnerability dictionaries
            
        Returns:
            Formatted string describing vulnerabilities
        """
        if not vulnerabilities:
            return "No specific vulnerabilities identified."
            
        formatted_text = ""
        for i, vuln in enumerate(vulnerabilities):
            vuln_type = vuln.get("type", "Unknown")
            formatted_text += f"{i+1}. Type: {vuln_type}\n"
            
            for field in ["location", "description", "exploitation", "constraints"]:
                if field in vuln:
                    formatted_text += f"   {field.capitalize()}: {vuln[field]}\n"
            
            formatted_text += "\n"
            
        return formatted_text
    
    def _replace_dummy_gadgets(self, exploit_code: str) -> str:
        """
        Analyze the exploit code and replace any dummy gadget addresses with real addresses.
        
        Args:
            exploit_code: The exploit code to analyze
            
        Returns:
            Updated exploit code with real gadget addresses
        """
        self.logger.info("Checking for dummy gadget addresses in exploit code")
        
        # Look for common dummy/placeholder addresses
        dummy_patterns = [
            (r'0x41414141', 'pop rdi; ret'),     # AAAA - often used for pop rdi
            (r'0x42424242', 'pop rsi; ret'),     # BBBB - often used for pop rsi
            (r'0x43434343', 'pop rdx; ret'),     # CCCC - often used for pop rdx
            (r'0x44444444', 'pop rax; ret'),     # DDDD - often used for pop rax
            (r'0xdeadbeef', 'ret'),              # Often used as a return address
            (r'0xcafebabe', 'pop rbp; ret'),     # Often used for pop rbp
            (r'0xdeadc0de', 'syscall; ret'),     # Often used for syscall
            (r'0xbaadf00d', 'pop rcx; ret'),     # Often used for pop rcx
            (r'0xfeedface', 'int 0x80; ret')     # Often used for int 0x80
        ]
        
        updated_code = exploit_code
        replacements_made = False
        
        # First check for stack address patterns
        stack_address_patterns = [
            (r'0xbf[a-f0-9]{6}', 'Stack address (32-bit)'),  # Common 32-bit stack addresses
            (r'0xff[a-f0-9]{6}', 'Stack address (32-bit)'),  # Common 32-bit stack addresses
            (r'0x7ff[a-f0-9]{8}', 'Stack address (64-bit)'), # Common 64-bit stack addresses
        ]
        
        for stack_pattern, description in stack_address_patterns:
            if re.search(stack_pattern, updated_code, re.IGNORECASE):
                self.logger.warning(f"Found potential hardcoded stack address matching {description}")
                # Add a warning comment to the code
                warning = (
                    "\n# WARNING: Hardcoded stack addresses detected! This is unreliable!\n"
                    "# Stack addresses change between runs and environments.\n"
                    "# Use a 'jmp esp' or similar gadget instead of jumping directly to stack\n"
                )
                # Add the warning after imports
                if "import" in updated_code and "def" in updated_code:
                    parts = updated_code.split("def", 1)
                    updated_code = parts[0] + warning + "def" + parts[1]
                else:
                    updated_code = warning + updated_code
                
                # This is serious enough to log a prominent warning
                stack_addr_match = re.search(stack_pattern, updated_code, re.IGNORECASE)
                addr = stack_addr_match.group(0) if stack_addr_match else "unknown"
                
                # Check if we have a jmp esp gadget available to suggest
                jmp_esp_gadget = self.get_real_gadget_address("jmp esp")
                if jmp_esp_gadget:
                    suggestion = f"\n# SUGGESTION: Use jmp esp gadget at {jmp_esp_gadget} instead of hardcoded stack address {addr}\n"
                    updated_code = updated_code.replace(warning, warning + suggestion)
        
        # Check for stack address comments and direct mentions
        stack_keywords = [
            "stack address", "buffer address", "shellcode address on stack",
            "address of our buffer", "stack pointer", "address of our shellcode"
        ]
        
        for keyword in stack_keywords:
            if keyword.lower() in updated_code.lower():
                # Add a warning about unreliable stack references
                warning = (
                    "\n# WARNING: References to stack addresses detected! This is unreliable!\n"
                    "# Use a 'jmp esp' or similar gadget instead of relying on stack addresses\n"
                )
                # Add the warning near the reference
                pattern = re.compile(r'(.*' + re.escape(keyword) + r'.*)', re.IGNORECASE)
                updated_code = pattern.sub(r'\1' + warning, updated_code)
        
        # Check for specific hardcoded addresses that aren't in our dummy patterns
        # but look suspicious (e.g., 0xffffd0f0)
        hardcoded_addr_pattern = r'0x[a-f0-9]{4,}[fd][0-9a-f]{3}'  # Matches patterns that look like stack addresses
        for match in re.finditer(hardcoded_addr_pattern, updated_code, re.IGNORECASE):
            addr = match.group(0)
            if not any(re.match(pattern, addr, re.IGNORECASE) for pattern, _ in dummy_patterns):
                # This is a suspicious address that's not in our dummy list
                if int(addr, 16) > 0x7f000000:  # Typical stack address range
                    warning_comment = f" # WARNING: Suspicious hardcoded address {addr}. Consider using a jmp esp gadget instead"
                    updated_code = updated_code.replace(addr, addr + warning_comment)
        
        # Now process the standard dummy addresses
        for dummy_addr, gadget_pattern in dummy_patterns:
            if re.search(dummy_addr, updated_code, re.IGNORECASE):
                self.logger.info(f"Found dummy address {dummy_addr}, attempting to replace with real gadget: {gadget_pattern}")
                
                # Find a real gadget address
                real_addr = self.get_real_gadget_address(gadget_pattern)
                if real_addr:
                    self.logger.info(f"Replacing {dummy_addr} with real address {real_addr}")
                    updated_code = re.sub(dummy_addr, real_addr, updated_code, flags=re.IGNORECASE)
                    replacements_made = True
                else:
                    self.logger.warning(f"Could not find real address for gadget pattern: {gadget_pattern}")
                    
                    # Add a comment in the code to warn about the dummy address
                    comment = f" # WARNING: Dummy address! Replace with actual {gadget_pattern} gadget address"
                    updated_code = updated_code.replace(dummy_addr, dummy_addr + comment)
        
        # Also look for commented gadget requests
        gadget_requests = re.findall(r'#\s*need\s+gadget\s*:\s*([^#\n]+)', updated_code, re.IGNORECASE)
        for request in gadget_requests:
            pattern = request.strip()
            self.logger.info(f"Found gadget request in comment: {pattern}")
            
            real_addr = self.get_real_gadget_address(pattern)
            if real_addr:
                self.logger.info(f"Found real address {real_addr} for requested gadget {pattern}")
                # Replace the comment with the actual address
                updated_code = updated_code.replace(f"# need gadget: {pattern}", real_addr)
                replacements_made = True
        
        # Also look for commented library gadget requests
        lib_gadget_requests = re.findall(r'#\s*need\s+gadget\s+from\s+(\w+)\s*:\s*([^#\n]+)', updated_code, re.IGNORECASE)
        for lib, pattern in lib_gadget_requests:
            pattern = pattern.strip()
            self.logger.info(f"Found gadget request from {lib}: {pattern}")
            
            real_addr = self.get_real_gadget_address(pattern, lib)
            if real_addr:
                self.logger.info(f"Found real address {real_addr} for requested gadget {pattern} from {lib}")
                # Replace the comment with the actual address
                updated_code = updated_code.replace(f"# need gadget from {lib}: {pattern}", real_addr)
                replacements_made = True
        
        if replacements_made:
            self.logger.info("Made replacements of dummy gadget addresses with real addresses")
        else:
            self.logger.info("No dummy gadget addresses needing replacement were found")
        
        # Add a final check for the common "jump to shellcode/buffer" pattern in exploits
        if "jmp esp" not in updated_code.lower() and "call esp" not in updated_code.lower():
            if "shellcode" in updated_code.lower():
                self.logger.warning("Shellcode detected but no jmp esp or call esp gadget found")
                # Try to find a jmp esp gadget
                jmp_esp = self.get_real_gadget_address("jmp esp")
                call_esp = self.get_real_gadget_address("call esp")
                
                if jmp_esp or call_esp:
                    gadget_addr = jmp_esp if jmp_esp else call_esp
                    gadget_type = "jmp esp" if jmp_esp else "call esp"
                    suggestion = (
                        f"\n# SUGGESTION: Use {gadget_type} gadget at {gadget_addr} to reach your shellcode\n"
                        f"# Example usage: payload = b'A'*offset + p32({gadget_addr}) + shellcode\n"
                    )
                    # Add after imports but before first function
                    if "def " in updated_code:
                        parts = updated_code.split("def ", 1)
                        updated_code = parts[0] + suggestion + "def " + parts[1]
                    else:
                        updated_code = updated_code + "\n" + suggestion
            
        return updated_code
    
    def _develop_exploit(self, exploitation_plan: str) -> Tuple[str, str]:
        """
        Develop an exploit based on the exploitation plan.
        
        Args:
            exploitation_plan: The exploitation plan to follow
            
        Returns:
            Tuple of (exploit code, exploit description)
        """
        # Get debugging results needed for exploitation
        overflow_offset = self.state.get("overflow_offset")
        gadgets = self.state.get("gadgets", [])
        leaked_addresses = self.state.get("leaked_addresses", {})
        security_features = self.state.get("security_features", {})
        
        # Get binary path - use absolute path to prevent file not found errors
        binary_path = str(self.binary_path.resolve())
        binary_name = os.path.basename(binary_path)
        
        # Find useful gadgets, especially jmp esp or equivalents
        useful_gadgets = self.find_useful_gadgets()
        jmp_esp_gadget = useful_gadgets.get("jmp_esp")
        
        if jmp_esp_gadget:
            self.logger.info(f"Found jmp esp gadget at {jmp_esp_gadget}")
        else:
            self.logger.warning("No jmp esp or equivalent gadget found - exploitation may be unreliable")
        
        # Format gadgets for the prompt
        gadgets_text = ""
        for i, gadget in enumerate(gadgets[:10]):  # Limit to top 10 gadgets
            addr = gadget.get("address", "unknown")
            instr = gadget.get("instruction", "unknown")
            gadgets_text += f"- `{instr}` at address {addr}\n"
        
        if len(gadgets) > 10:
            gadgets_text += f"... and {len(gadgets) - 10} more gadgets\n"
            
        # Create prompt for the LLM
        prompt = f"""
        Please develop a Python exploit script using pwntools for the vulnerability described in the exploitation plan.
        
        ## EXPLOITATION PLAN
        {exploitation_plan}
        
        ## BINARY INFORMATION
        - Binary absolute path: {binary_path}
        - Binary name: {binary_name}
        
        ## DEBUGGING INFORMATION
        - Buffer Overflow Offset: {overflow_offset if overflow_offset is not None else "Not determined"}
        - Security Features:
          - NX: {security_features.get("nx", "unknown")}
          - Canary: {security_features.get("canary", "unknown")}
          - PIE: {security_features.get("pie", "unknown")}
          - RELRO: {security_features.get("relro", "unknown")}
        - Available Gadgets:
        {gadgets_text}
        - Leaked Addresses: {leaked_addresses}
        
        ## IMPORTANT REQUIREMENTS FOR RELIABLE EXPLOITATION
        1. NEVER use hardcoded stack addresses, as they change between runs and environments
        2. For stack-based exploits with shellcode:
           - Use the "jmp esp" gadget at {jmp_esp_gadget if jmp_esp_gadget else "address (not found - need alternative approach)"}
           - Place your shellcode after the return address
           - Return to the jmp esp gadget to execute your shellcode
        3. For format string exploits:
           - Calculate the correct position for your format specifiers
           - Use %n to write to memory precisely
        4. For ROP chains:
           - Use only the gadgets provided above or request specific ones
           - Chain gadgets together in the correct order for your exploit goal
        
        Create a complete, well-commented Python exploit script that implements the exploitation plan.
        Use pwntools functions like p64(), p32(), log.info(), etc. as needed.
        The script should work both locally and against a remote target.
        
        IMPORTANT: Your exploit needs to work in both interactive and automated testing modes. For automated testing, 
        the script shouldn't call io.interactive() unconditionally, as this will cause the automated tester to hang.
        
        Use the following template to structure your exploit:
        
        ```python
        #!/usr/bin/env python3
        from pwn import *
        import sys
        
        # Set up context for architecture
        context.binary = "{binary_path}"  # IMPORTANT: Use this exact binary path
        
        # Define exploit function
        def exploit(target, automatic_mode=False):
            # Connect to target
            io = target
            
            # [Your exploit code here]
            
            # For automated testing, check if we got a shell or the flag without using interactive()
            if automatic_mode:
                # Try to execute a command to verify we have a shell, or check for flag
                # For example, if we have a shell:
                io.sendline(b"echo pwned")
                result = io.recvline_contains(b"pwned", timeout=2)
                if result:
                    log.success("Exploit successful!")
                    return True
                else:
                    log.error("Exploit failed")
                    return False
            else:
                # Only call interactive in manual mode
                log.success("Switching to interactive mode...")
                io.interactive()
        
        if __name__ == "__main__":
            # Set up logging
            context.log_level = 'info'
            
            # Check if running in automatic testing mode
            automatic_mode = "--automatic" in sys.argv
            
            # Local exploitation - IMPORTANT: Use the absolute path to the binary
            binary_path = "{binary_path}"  # This must be the absolute path
            log.info(f"Exploiting binary at {{binary_path}}")
            
            # Run exploit
            if "--remote" in sys.argv and len(sys.argv) > 2:
                host, port = sys.argv[2].split(":")
                log.info(f"Exploiting remotely at {{host}}:{{port}}")
                target = remote(host, int(port))
                result = exploit(target, automatic_mode)
                if automatic_mode and result:
                    print("EXPLOIT_SUCCESS")
            else:
                log.info("Exploiting locally")
                target = process([binary_path])
                result = exploit(target, automatic_mode)
                if automatic_mode and result:
                    print("EXPLOIT_SUCCESS")
        ```
        
        Make sure to replace placeholder values with actual values from the debugging information.
        Include detailed comments explaining each step of the exploit.
        IMPORTANT: Do NOT use placeholder paths like './vulnerable_binary'. Use the exact path I provided.
        CRITICAL: Make sure the automatic_mode code works to verify if the exploit was successful without user interaction.
        """
        
        # Add the useful gadgets section to the prompt
        prompt = self.update_exploit_prompt_with_gadgets(prompt)
        
        # Add shellcode file information if available
        shellcode_file = self.get_from_state("shellcode_file")
        if shellcode_file and os.path.exists(shellcode_file):
            try:
                with open(shellcode_file, 'rb') as f:
                    shellcode = f.read()
                    shellcode_size = len(shellcode)
                    
                shellcode_section = f"""
        ## CUSTOM SHELLCODE
        A custom shellcode file has been provided at '{shellcode_file}' ({shellcode_size} bytes).
        
        Your exploit should use this shellcode instead of generating its own. Include code like this in your exploit:
        
        ```python
        # Load the custom shellcode from file
        with open("{shellcode_file}", "rb") as f:
            shellcode = f.read()
        ```
        
        Then use this shellcode in your payload construction instead of generating shellcode with pwntools.
        """
                prompt += shellcode_section
                
            except Exception as e:
                self.logger.warning(f"Failed to read shellcode file {shellcode_file}: {e}")
                
        # Add source code information if available
        source_code = self.read_source_file()
        if source_code:
            source_section = f"""
        ## SOURCE CODE
        ```c
        {source_code}
        ```
        
        Use the source code to identify specific vulnerabilities and craft a more precise exploit.
        """
            prompt = prompt.replace("## DEBUGGING INFORMATION", source_section + "\n## DEBUGGING INFORMATION")
        
        # Add user feedback if available
        prompt = self.incorporate_feedback(prompt)
        
        # Call LLM
        self.logger.info("Generating exploit code...")
        response = self.llm.call(prompt)
        
        # Extract the code and description
        exploit_code = ""
        description = ""
        
        # Parse the response to extract just the code
        if "```python" in response:
            parts = response.split("```python", 1)
            description = parts[0].strip()
            if "```" in parts[1]:
                code_part = parts[1].split("```", 1)[0]
                exploit_code = code_part.strip()
            else:
                exploit_code = parts[1].strip()
        elif "```" in response:
            parts = response.split("```", 2)
            if len(parts) >= 3:
                description = parts[0].strip()
                exploit_code = parts[1].strip()
                if not description and len(parts) > 2:
                    description = parts[2].strip()
            else:
                exploit_code = response
        else:
            exploit_code = response
        
        # Process the code to ensure binary paths are correct
        exploit_code = exploit_code.replace("./vulnerable_binary", binary_path)
        exploit_code = exploit_code.replace("./binary_name", binary_path)
        
        # Replace any dummy gadget addresses with real addresses
        exploit_code = self._replace_dummy_gadgets(exploit_code)
        
        # Save exploit to file
        exploit_path = self.output_dir / "exploit.py"
        with open(exploit_path, "w") as f:
            f.write(exploit_code)
            
        self.logger.info(f"Saved exploit to {exploit_path}")
        
        # Make the exploit executable
        os.chmod(exploit_path, 0o755)
        
        return exploit_code, description
    
    def _extract_code(self, response: str) -> str:
        """
        Extract Python code from an LLM response.
        
        Args:
            response: The LLM response text
            
        Returns:
            The extracted Python code
        """
        # Look for Python code blocks
        python_blocks = re.findall(r'```(?:python)?\s*\n(.*?)```', response, re.DOTALL)
        
        if python_blocks:
            # Use the longest code block (most likely the full script)
            code = max(python_blocks, key=len)
        else:
            # If no code blocks found, try to extract all the script
            # by looking for common Python syntax
            potential_script = ""
            in_script = False
            
            for line in response.split('\n'):
                if not in_script and (line.startswith('from ') or line.startswith('import ') or 
                                    line.startswith('#!/usr/bin/env python')):
                    in_script = True
                    potential_script += line + '\n'
                elif in_script:
                    potential_script += line + '\n'
            
            if potential_script:
                code = potential_script
            else:
                # As a fallback, just return the entire response
                code = response
        
        # Fix common issues in the generated code
        # Fix incorrect process() calls
        code = re.sub(
            r'process\s*\(\s*context\.binary\s*\)', 
            r'process([context.binary.path])', 
            code
        )
        code = re.sub(
            r'process\s*\(\s*[\'"](.+?)[\'"]\s*\)', 
            r'process([\1])', 
            code
        )
        
        return code
    
    def _test_exploit(self) -> Tuple[bool, Dict[str, Any], str]:
        """
        Test the exploit script locally.
            
        Returns:
            Tuple of (success boolean, result dictionary, output text)
        """
        self.logger.info("Testing exploit script locally")
        
        # Check if the exploit script exists
        exploit_path = self.output_dir / "exploit.py"
        if not os.path.exists(exploit_path):
            self.logger.error(f"Exploit script not found at {exploit_path}")
            return False, {}, f"Error: Exploit script not found at {exploit_path}"
        
        try:
            # Set up environment variables
            env = os.environ.copy()
            env["TERM"] = "xterm-256color"  # Set a standard terminal type
            env["PWNLIB_NOTERM"] = "true"  # Disable terminal features that might cause issues
            
            # Run the exploit in automatic testing mode
            cmd = [sys.executable, str(exploit_path), "--automatic"]
            if self.remote_host and self.remote_port:
                # If testing locally, add --local flag if script supports it
                cmd.extend(["--remote", f"{self.remote_host}:{self.remote_port}"])
            
            self.logger.debug(f"Running command: {' '.join(cmd)}")
            
            # Run with a timeout
            proc = subprocess.run(
                cmd,
                env=env,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True,
                timeout=30  # 30 second timeout for exploit
            )
            
            # Capture the output
            output = proc.stdout + "\n" + proc.stderr
            
            # Check for success indicators in output
            success_indicators = ["EXPLOIT_SUCCESS", "pwned", "shell", "success", "flag{", "CTF{", "FLAG{"]
            success = any(indicator.lower() in output.lower() for indicator in success_indicators)
            
            # If the exploit seems to have succeeded but returned non-zero, warn but don't fail
            if proc.returncode != 0:
                self.logger.warning(f"Exploit test returned code {proc.returncode}, may not be successful")
            
            # Parse the output to extract result data
            result = {}
            for indicator in success_indicators:
                if indicator.lower() in output.lower():
                    result[indicator.replace("{", "").replace("}", "").replace("CTF", "").replace("flag", "").replace("pwned", "").replace("shell", "").replace("success", "")] = True
            
            return success, result, output
        
        except subprocess.TimeoutExpired:
            self.logger.warning("Exploit test timed out")
            return False, {}, "Timeout: Exploit test took too long to complete"
        
        except Exception as e:
            self.logger.error(f"Error testing exploit: {str(e)}")
            return False, {}, f"Error: {str(e)}"
    
    def _analyze_failure(self, failure_data: Dict[str, Any]) -> Dict[str, Any]:
        """
        Analyze why an exploit attempt failed.
        
        Args:
            failure_data: Data about the failed exploit attempt including output and code
            
        Returns:
            Dictionary with analysis results including potential fixes
        """
        output = failure_data.get("output", "")
        exploit_code = failure_data.get("exploit_code", "")
        iteration = failure_data.get("iteration", 0)
        user_feedback = failure_data.get("user_feedback", "")
        
        self.logger.info(f"Analyzing failure from iteration {iteration}")
        
        # Create a prompt for LLM to analyze the failure
        prompt = f"""
        I'm trying to develop an exploit for a binary, but my exploit attempt failed.
        Please analyze the exploit code and the program output to determine why it failed
        and suggest specific changes to fix the issues.
        
        ## EXPLOIT CODE
        ```python
        {exploit_code}
        ```
        
        ## PROGRAM OUTPUT
        ```
        {output}
        ```
        """
        
        # Add user feedback if available
        if user_feedback:
            # Check if the feedback is from GDB debugging session
            if "GDB debugging session" in user_feedback.lower() or self._looks_like_gdb_output(user_feedback):
                prompt += f"""
        ## GDB DEBUGGING INSIGHTS
        The user provided the following insights from interactive GDB debugging:
        {user_feedback}
        
        These GDB debugging insights are extremely valuable as they represent direct 
        observations of the program's behavior during exploitation. They should be
        given the highest priority when refining the exploit.
        
        Make sure to address any specific issues identified in the debugging session,
        such as incorrect memory addresses, register values, payload structure, or
        timing issues.
        """
            else:
                prompt += f"""
        ## USER FEEDBACK
        The user provided the following explanation of why the exploit failed:
        {user_feedback}
        
        This feedback should take priority when refining the exploit.
        """
        
        prompt += """
        Based on this information, please:
        1. Identify the specific reason(s) for failure
        2. Suggest precise fixes/changes to the exploit code
        3. Explain any conceptual misunderstandings or incorrect assumptions in the exploit
        
        Return your analysis in this format:
        ```
        FAILURE_REASON: [Brief description of why the exploit failed]
        ISSUES:
        - [Issue 1]
        - [Issue 2]
        ...
        PROPOSED_FIXES:
        - [Fix 1]
        - [Fix 2]
        ...
        EXPLANATION: [Detailed explanation of what went wrong and how the fixes address the issues]
        ```
        """
        
        # Incorporate source file if available
        prompt = self.incorporate_source(prompt)
        
        # Call LLM
        self.logger.debug("Sending failure analysis request to LLM")
        response = self.llm.call(prompt)
        
        # Parse the response to extract structured information
        analysis = self._parse_failure_analysis(response)
        
        # If user provided feedback, add it to the analysis
        if user_feedback:
            analysis["user_feedback"] = user_feedback
        
        # Save the analysis to a file
        analysis_path = self.output_dir / f"failure_analysis_iteration_{iteration}.txt"
        with open(analysis_path, "w") as f:
            f.write(response)
            # Add user feedback to the saved file if available
            if user_feedback:
                f.write(f"\n\nUSER FEEDBACK:\n{user_feedback}")
        
        self.logger.info(f"Saved failure analysis to {analysis_path}")
        
        return analysis
    
    def _parse_failure_analysis(self, response: str) -> Dict[str, Any]:
        """
        Parse the LLM's failure analysis response into a structured format.
        
        Args:
            response: The LLM's analysis text
            
        Returns:
            Dictionary with structured failure analysis
        """
        analysis = {
            "failure_reason": "",
            "issues": [],
            "proposed_fixes": [],
            "explanation": "",
            "summary": "",
            "full_analysis": response
        }
        
        # Extract failure reason
        if "FAILURE_REASON:" in response:
            parts = response.split("FAILURE_REASON:", 1)
            reason_part = parts[1].split("\n", 1)[0].strip()
            analysis["failure_reason"] = reason_part
            analysis["summary"] = reason_part
        
        # Extract issues
        if "ISSUES:" in response:
            parts = response.split("ISSUES:", 1)
            issues_part = parts[1].split("PROPOSED_FIXES:" if "PROPOSED_FIXES:" in parts[1] else "EXPLANATION:", 1)[0]
            issues = []
            for line in issues_part.strip().split("\n"):
                if line.strip().startswith("-"):
                    issues.append(line.strip()[1:].strip())
            analysis["issues"] = issues
        
        # Extract proposed fixes
        if "PROPOSED_FIXES:" in response:
            parts = response.split("PROPOSED_FIXES:", 1)
            fixes_part = parts[1].split("EXPLANATION:" if "EXPLANATION:" in parts[1] else "\n\n", 1)[0]
            fixes = []
            for line in fixes_part.strip().split("\n"):
                if line.strip().startswith("-"):
                    fixes.append(line.strip()[1:].strip())
            analysis["proposed_fixes"] = fixes
        
        # Extract explanation
        if "EXPLANATION:" in response:
            parts = response.split("EXPLANATION:", 1)
            explanation = parts[1].strip()
            analysis["explanation"] = explanation
        
        return analysis
    
    def _refine_exploit(self, exploitation_plan: str, failure_data: Dict[str, Any]) -> Tuple[str, str]:
        """
        Refine an exploit based on failure analysis.
        
        Args:
            exploitation_plan: The current exploitation plan
            failure_data: Data about the failed exploit attempt
            
        Returns:
            Tuple of (refined exploit code, description)
        """
        # Analyze the failure if not already done
        if "analysis" not in failure_data:
            failure_analysis = self._analyze_failure(failure_data)
        else:
            failure_analysis = failure_data["analysis"]
        
        # Extract key information
        previous_code = failure_data.get("exploit_code", "")
        issues = failure_analysis.get("issues", [])
        proposed_fixes = failure_analysis.get("proposed_fixes", [])
        failure_reason = failure_analysis.get("failure_reason", "Unknown failure")
        user_feedback = failure_data.get("user_feedback", "")
        
        # Find jmp esp or equivalent gadget
        useful_gadgets = self.find_useful_gadgets()
        jmp_esp_gadget = useful_gadgets.get("jmp_esp")
        
        # Check if the issue might be related to stack addresses
        stack_address_issue = any("stack address" in issue.lower() for issue in issues)
        stack_address_issue = stack_address_issue or any("hardcoded address" in issue.lower() for issue in issues)
        stack_address_issue = stack_address_issue or any("buffer address" in issue.lower() for issue in issues)
        
        # Create a prompt for LLM to refine the exploit
        prompt = f"""
        I need to refine an exploit that failed. Please create an improved version 
        based on the failure analysis and proposed fixes.
        
        ## PREVIOUS EXPLOIT CODE
        ```python
        {previous_code}
        ```
        
        ## FAILURE ANALYSIS
        Failure reason: {failure_reason}
        
        Issues identified:
        {chr(10).join(['- ' + issue for issue in issues])}
        
        Proposed fixes:
        {chr(10).join(['- ' + fix for fix in proposed_fixes])}
        """
        
        # If we found a jmp esp gadget and the issue might be stack-related, emphasize it
        if jmp_esp_gadget and stack_address_issue:
            prompt += f"""
        ## IMPORTANT: USE JMP ESP GADGET
        The exploit failed possibly due to unreliable stack addresses. Use the jmp esp gadget at {jmp_esp_gadget}
        to reliably jump to your shellcode. Place your shellcode after the return address in your buffer and
        return to the jmp esp gadget.
        
        Example payload construction:
        ```python
        payload = b'A' * offset + p32({jmp_esp_gadget}) + shellcode
        ```
        
        This is much more reliable than trying to return directly to a hardcoded stack address.
        """
        
        # Add user feedback if available
        if user_feedback:
            prompt += f"""
        ## USER FEEDBACK
        The user provided the following explanation of why the exploit failed:
        {user_feedback}
        
        This feedback should take priority when refining the exploit.
        """
            
        prompt += f"""
        ## EXPLOITATION PLAN
        {exploitation_plan}
        
        ## CRITICAL REQUIREMENTS FOR RELIABLE EXPLOITATION
        1. NEVER use hardcoded stack addresses, as they change between runs and environments
        2. For stack-based exploits with shellcode:
           - Use the "jmp esp" gadget at {jmp_esp_gadget if jmp_esp_gadget else "address (not found - need alternative approach)"}
           - Place your shellcode after the return address
           - Return to the jmp esp gadget to execute your shellcode
        3. Ensure your payload is correctly aligned and sized
        4. Handle byte encoding issues (null bytes, newlines, etc.) appropriately
        5. Make sure timeout values in your code are appropriate
        
        Please create a completely new, refined exploit that addresses all the issues 
        identified in the failure analysis. Make sure the exploit follows the general 
        approach outlined in the exploitation plan, but incorporates the necessary 
        fixes to overcome the failure.
        
        Write a complete, executable Python script using pwntools. Include detailed 
        comments explaining your changes and how they address the previous issues.
        """
        
        # Add the useful gadgets section to the prompt
        prompt = self.update_exploit_prompt_with_gadgets(prompt)
        
        # Incorporate source file if available
        prompt = self.incorporate_source(prompt)
        
        # Call LLM
        self.logger.info("Generating refined exploit")
        response = self.llm.call(prompt)
        
        # Extract the code and description
        exploit_code = ""
        description = ""
        
        # Parse the response to extract just the code
        if "```python" in response:
            parts = response.split("```python", 1)
            description = parts[0].strip()
            if "```" in parts[1]:
                code_part = parts[1].split("```", 1)[0]
                exploit_code = code_part.strip()
            else:
                exploit_code = parts[1].strip()
        elif "```" in response:
            parts = response.split("```", 2)
            if len(parts) >= 3:
                description = parts[0].strip()
                exploit_code = parts[1].strip()
                if not description and len(parts) > 2:
                    description = parts[2].strip()
            else:
                exploit_code = response
        else:
            exploit_code = response
        
        # Process the code to ensure binary paths are correct
        binary_path = str(self.binary_path.resolve())
        exploit_code = exploit_code.replace("./vulnerable_binary", binary_path)
        exploit_code = exploit_code.replace("./binary_name", binary_path)
        
        # Replace any dummy gadget addresses with real addresses
        exploit_code = self._replace_dummy_gadgets(exploit_code)
        
        # Save exploit to file
        exploit_path = self.output_dir / "exploit.py"
        with open(exploit_path, "w") as f:
            f.write(exploit_code)
            
        # Save the iteration-specific copy
        iteration = failure_data.get("iteration", 0) + 1
        iteration_path = self.output_dir / f"exploit_iteration_{iteration}.py"
        with open(iteration_path, "w") as f:
            f.write(exploit_code)
            
        self.logger.info(f"Saved refined exploit to {exploit_path} and {iteration_path}")
        
        # Make the exploit executable
        os.chmod(exploit_path, 0o755)
        
        return exploit_code, description
    
    def _update_exploitation_plan(self, exploitation_plan: str, failure_analysis: Dict[str, Any]) -> str:
        """
        Update the exploitation plan based on failure analysis.
        
        Args:
            exploitation_plan: The current exploitation plan
            failure_analysis: The analysis of the exploit failure
            
        Returns:
            Updated exploitation plan
        """
        # Extract key information from failure analysis
        failure_reason = failure_analysis.get("failure_reason", "Unknown failure")
        issues = failure_analysis.get("issues", [])
        proposed_fixes = failure_analysis.get("proposed_fixes", [])
        explanation = failure_analysis.get("explanation", "")
        user_feedback = failure_analysis.get("user_feedback", "")
        
        # Create a prompt for LLM to update the plan
        prompt = f"""
        I need to update an exploitation plan based on failure analysis.
        
        ## CURRENT EXPLOITATION PLAN
        {exploitation_plan}
        
        ## FAILURE ANALYSIS
        Failure reason: {failure_reason}
        
        Issues identified:
        {chr(10).join(['- ' + issue for issue in issues])}
        
        Proposed fixes:
        {chr(10).join(['- ' + fix for fix in proposed_fixes])}
        
        Explanation: {explanation}
        """
        
        # Add user feedback if available
        if user_feedback:
            # Check if the feedback is from GDB debugging session
            if "GDB debugging session" in user_feedback.lower() or self._looks_like_gdb_output(user_feedback):
                prompt += f"""
        ## GDB DEBUGGING INSIGHTS
        The user provided the following insights from interactive GDB debugging:
        {user_feedback}
        
        These GDB debugging insights are extremely valuable as they represent direct 
        observations of the program's behavior during exploitation. They should be
        given the highest priority when refining the exploit.
        
        Make sure to address any specific issues identified in the debugging session,
        such as incorrect memory addresses, register values, payload structure, or
        timing issues.
        """
            else:
                prompt += f"""
        ## USER FEEDBACK
        The user provided the following explanation of why the exploit failed:
        {user_feedback}
        
        This feedback should take priority when refining the exploit.
        """
        
        # Add shellcode file information if available
        shellcode_file = self.get_from_state("shellcode_file")
        if shellcode_file and os.path.exists(shellcode_file):
            try:
                with open(shellcode_file, 'rb') as f:
                    shellcode = f.read()
                    shellcode_size = len(shellcode)
                    
                prompt += f"""
        ## CUSTOM SHELLCODE
        Remember to incorporate the custom shellcode file provided at '{shellcode_file}' ({shellcode_size} bytes).
        The exploit should load and use this shellcode instead of generating its own.
        """
            except Exception as e:
                self.logger.warning(f"Failed to read shellcode file {shellcode_file}: {e}")
        
        prompt += """
        Please revise the exploitation plan to address the issues identified in the failure analysis.
        The updated plan should incorporate the lessons learned from the failed attempt and provide
        clearer guidance on how to develop a successful exploit.
        
        Keep the fundamental approach if it's still valid, but adjust any incorrect assumptions,
        add missing details, and correct any technical inaccuracies.
        
        Return a complete, updated exploitation plan that can be used to guide the next exploit attempt.
        """
        
        # Call LLM
        self.logger.info("Updating exploitation plan based on failure analysis")
        updated_plan = self.llm.call(prompt)
        
        return updated_plan
    
    def _run_remote_exploit(self) -> Dict[str, Any]:
        """
        Run the developed exploit against a remote target.
        
        Returns:
            Dictionary with the remote exploitation results
        """
        self.logger.info("Attempting remote exploitation")
        
        # Check if we have a remote target specified
        remote_target = self.state.get("remote_target")
        if not remote_target:
            self.logger.error("No remote target specified")
            return {"exploit_successful": False, "error": "No remote target specified"}
        
        # Parse the remote target
        try:
            host, port_str = remote_target.split(":")
            port = int(port_str)
        except ValueError:
            self.logger.error(f"Invalid remote target format: {remote_target}")
            return {"exploit_successful": False, "error": "Invalid remote target format"}
        
        # Check if we have an exploit script
        exploit_path = self.output_dir / "exploit.py"
        if not exploit_path.exists():
            self.logger.error("No exploit script found")
            return {"exploit_successful": False, "error": "No exploit script found"}
        
        try:
            # Run the exploit with REMOTE=1 environment variable
            env = os.environ.copy()
            env["REMOTE"] = "1"
            env["HOST"] = host
            env["PORT"] = str(port)
            env["PWNLIB_NOTERM"] = "true"  # Disable terminal features
            
            cmd = [sys.executable, str(exploit_path), "--remote", f"{host}:{port}"]
            
            self.logger.info(f"Running command: {' '.join(cmd)}")
            
            # Run with timeout
            proc = subprocess.run(
                cmd,
                env=env,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True,
                timeout=60  # 60 second timeout for remote exploitation
            )
            
            output = proc.stdout + "\n" + proc.stderr
            
            # Save the remote output
            remote_output_path = self.output_dir / "remote_exploitation_output.txt"
            with open(remote_output_path, "w") as f:
                f.write(output)
            
            # Check for success indicators
            success_indicators = ["flag{", "CTF{", "pwned", "shell", "success", "FLAG{"]
            success = any(indicator.lower() in output.lower() for indicator in success_indicators)
            
            # Try to extract the flag if successful
            flag = None
            if success:
                # Look for flag pattern
                flag_pattern = re.compile(r'(flag|FLAG|ctf|CTF)\{[^}]+\}')
                flag_match = flag_pattern.search(output)
                if flag_match:
                    flag = flag_match.group(0)
            
            self.logger.info(f"Remote exploitation {'successful' if success else 'failed'}")
            
            return {
                "exploit_successful": success,
                "flag": flag,
                "remote_output": output[:1000]  # Truncate very long output
            }
            
        except subprocess.TimeoutExpired:
            self.logger.warning("Remote exploitation timed out")
            return {"exploit_successful": False, "error": "Timeout during remote exploitation"}
            
        except Exception as e:
            self.logger.error(f"Error during remote exploitation: {str(e)}")
            return {"exploit_successful": False, "error": str(e)}

    def _debug_crash_in_gdb(self) -> str:
        """
        Debug the crash in GDB and return insights.
        
        Returns:
            Debugging insights as a string
        """
        self.logger.info("Starting interactive GDB session for crash debugging")
        
        # Path to the binary and exploit script
        binary_path = str(self.binary_path.resolve())
        exploit_path = self.output_dir / "exploit.py"
        
        if not os.path.exists(exploit_path):
            print("Error: Exploit script not found.")
            return ""
        
        # Create a GDB init file with commands to set up the environment
        init_file = self.output_dir / "gdbinit.txt"
        with open(init_file, "w") as f:
            f.write("set disassembly-flavor intel\n")
            f.write("set pagination off\n")
            f.write("set follow-fork-mode child\n")  # Follow child processes
            
            # Add symbols if available
            f.write(f"file {binary_path}\n")
            
            # Add some helpful commands
            f.write("# Custom helper commands\n")
            f.write("define whereami\n")
            f.write("  info registers\n")
            f.write("  x/i $pc\n")
            f.write("  backtrace\n")
            f.write("end\n")
            
            # Don't auto-run - let the user control execution
            f.write("# Debugging is ready - exploit will be launched separately\n")
        
        print("\n" + "="*80)
        print("INTERACTIVE GDB DEBUGGING SESSION")
        print("="*80)
        print("The binary will be loaded in GDB. You'll need to perform the following steps:")
        print(" 1. Set any breakpoints you want")
        print(" 2. Run the binary with 'r' or 'run'")
        print(" 3. The exploit will be launched automatically when GDB starts")
        print("\nHelpful GDB commands:")
        print(" - bt or backtrace: Show the call stack")
        print(" - info registers: Show register values")
        print(" - x/10i $pc: Examine 10 instructions at program counter")
        print(" - x/10xw $sp: Examine 10 words on the stack")
        print(" - whereami: Custom command showing location info")
        print(" - pattern create 100: Create a cyclic pattern (if pwndbg/gef installed)")
        print(" - pattern search 0x41414141: Find offset in pattern (if pwndbg/gef installed)")
        print("\nType 'quit' or 'q' to exit GDB when you're done.")
        print("-"*80)
        
        try:
            # Create a pipe for stdin to attach to user terminal
            # This is key for full interactive mode
            
            # Build the GDB command
            cmd = [
                "gdb", 
                "-q",                      # Quiet mode
                "-x", str(init_file),      # Init file with commands
                binary_path                # The binary to debug
            ]
            
            # Launch GDB in interactive mode
            process = subprocess.Popen(
                cmd,
                stdin=None,                # Attach to user's terminal input
                stdout=None,               # Attach to user's terminal output
                stderr=None,               # Attach to user's terminal error output
                env=os.environ.copy()
            )
            
            # Execute the exploit script in a separate process
            time.sleep(1)  # Give GDB time to start
            print("\nLaunching exploit script...")
            exploit_process = subprocess.Popen(
                [sys.executable, str(exploit_path)],
                env=os.environ.copy()
            )
            
            # Wait for the GDB process to complete (when user quits)
            process.wait()
            
            # Try to terminate the exploit process if it's still running
            try:
                exploit_process.terminate()
            except:
                pass
            
            print("\n" + "="*80)
            print("GDB SESSION COMPLETED")
            print("="*80)
            
            # Get insights from the user
            print("Please share any insights you gained from the debugging session (memory addresses,")
            print("crash location, register values, what went wrong, etc.):")
            debug_insights = input("> ").strip()
            
            if debug_insights:
                # Save insights to a file
                insights_file = self.output_dir / "debug_insights.txt"
                with open(insights_file, "a") as f:
                    f.write(f"\n--- GDB Debugging Session Insights ---\n")
                    f.write(f"Timestamp: {time.strftime('%Y-%m-%d %H:%M:%S')}\n")
                    f.write(f"{debug_insights}\n")
                    f.write(f"--------------------------------------\n")
                
                self.logger.info(f"Saved debugging insights to {insights_file}")
                return debug_insights
            else:
                print("No insights provided.")
                return ""
                
        except Exception as e:
            self.logger.error(f"Error in GDB debugging session: {str(e)}")
            print(f"Error during debugging: {str(e)}")
            return ""
    
    def _looks_like_gdb_output(self, text: str) -> bool:
        """
        Check if the provided text looks like it contains GDB debugging output or insights.
        
        Args:
            text: The text to check
            
        Returns:
            True if the text appears to be GDB related, False otherwise
        """
        gdb_indicators = [
            "gdb", "breakpoint", "segfault", "sigsegv", "sigabrt", "sigill",
            "registers", "backtrace", "stack frame", "program counter", "eip", "rip",
            "memory address", "disassembly", "register dump", "core dump",
            "0x", "(gdb)", "program received signal", "bt", "info reg", "x/", "examine",
            "stack pointer", "esp", "rsp"
        ]
        
        text_lower = text.lower()
        for indicator in gdb_indicators:
            if indicator in text_lower:
                return True
        
        return False

    def _incorporate_vulnerability_feedback(self, prompt: str, vulnerability: Dict[str, Any]) -> str:
        """
        Incorporate vulnerability-specific feedback into the prompt.
        
        Args:
            prompt: The current prompt text
            vulnerability: The vulnerability dictionary
            
        Returns:
            Updated prompt text
        """
        # Extract relevant information from the vulnerability
        vuln_type = vulnerability.get("type", "Unknown")
        location = vulnerability.get("location", "Unknown")
        description = vulnerability.get("description", "No description provided")
        exploitation = vulnerability.get("exploitation", "No exploitation strategy provided")
        constraints = vulnerability.get("constraints", "No constraints specified")
        
        # Build a specific prompt for the vulnerability
        vuln_prompt = f"""
        ## VULNERABILITY DETAILS
        - Type: {vuln_type}
        - Location: {location}
        - Description: {description}
        - Exploitation: {exploitation}
        - Constraints: {constraints}
        
        Based on this information, please:
        1. Identify specific techniques to exploit this vulnerability
        2. Craft a payload that takes advantage of the vulnerability
        3. Ensure the exploit adheres to the constraints
        """
        
        # Incorporate the vulnerability-specific prompt into the existing prompt
        prompt += vuln_prompt
        
        return prompt

    def _incorporate_source(self, prompt: str) -> str:
        """
        Incorporate source code information into the prompt.
        
        Args:
            prompt: The current prompt text
            
        Returns:
            Updated prompt text
        """
        # Extract source code from the binary
        source_code = self.read_source_file()
        
        if source_code:
            source_section = f"""
        ## SOURCE CODE
        ```c
        {source_code}
        ```
        
        Use the source code to identify specific vulnerabilities and craft a more precise exploit.
        """
            prompt = prompt.replace("## DEBUGGING INFORMATION", source_section + "\n## DEBUGGING INFORMATION")
        
        return prompt

    def _incorporate_feedback(self, prompt: str) -> str:
        """
        Incorporate user feedback into the prompt.
        
        Args:
            prompt: The current prompt text
            
        Returns:
            Updated prompt text
        """
        # Extract user feedback from the state
        user_feedback = self.state.get("user_feedback", "")
        
        if user_feedback:
            feedback_section = f"""
        ## USER FEEDBACK
        The user provided the following feedback:
        {user_feedback}
        
        This feedback should be considered when developing the exploit.
        """
            prompt += feedback_section
        
        return prompt

    def read_source_file(self) -> str:
        """
        Read the source code of the binary.
        
        Returns:
            The source code of the binary as a string
        """
        # Implement the logic to read the source code of the binary
        # This is a placeholder and should be replaced with the actual implementation
        return ""

    def find_gadget(self, pattern: str, library: Optional[str] = None) -> Optional[Dict[str, Any]]:
        """
        Find a specific gadget in the binary or a library.
        
        Args:
            pattern: Gadget pattern to search for (e.g., "pop rdi; ret")
            library: Optional library name to search in (e.g., "libc")
            
        Returns:
            Dictionary with gadget information if found, None otherwise
        """
        # Use the GDB wrapper to find the gadget
        return self.gdb.find_specific_gadget(pattern, library)
    
    def get_real_gadget_address(self, pattern: str) -> Optional[str]:
        """
        Get the real address of a gadget for use in an exploit.
        
        Args:
            pattern: Gadget pattern to search for (e.g., "pop rdi; ret")
            
        Returns:
            String with the hex address of the gadget if found, None otherwise
        """
        gadget = self.find_gadget(pattern)
        if gadget:
            # Return the address as a hex string
            return gadget["address"]
        
        # Try in libc if not found in the binary and if ASLR is disabled
        security_features = self.state.get("security_features", {})
        if not security_features.get("pie", True):  # If PIE is disabled, likely ASLR is also disabled
            libc_gadget = self.find_gadget(pattern, "libc")
            if libc_gadget:
                return libc_gadget["address"]
        
        # Check if we have leaked addresses that might help
        leaked_addresses = self.state.get("leaked_addresses", {})
        if leaked_addresses:
            self.logger.info("Trying to use leaked addresses for gadget search")
            for library, base_addr in leaked_addresses.items():
                if isinstance(base_addr, int) or (isinstance(base_addr, str) and base_addr.startswith("0x")):
                    # Convert string address to int if needed
                    if isinstance(base_addr, str):
                        base_addr = int(base_addr, 16)
                    
                    # Try to find the gadget in this library with the leaked address
                    libc_gadget = self.find_gadget(pattern, library)
                    if libc_gadget:
                        return libc_gadget["address"]
        
        self.logger.warning(f"Could not find real address for gadget: {pattern}")
        return None
    
    def verify_gadget_address(self, addr: str) -> bool:
        """
        Verify that a gadget address is valid (not a dummy address).
        
        Args:
            addr: Gadget address to verify
            
        Returns:
            True if the address is a valid, real gadget address, False otherwise
        """
        if not addr:
            return False
            
        # Convert string address to int if needed
        if isinstance(addr, str):
            try:
                addr_int = int(addr, 16)
            except ValueError:
                return False
        else:
            addr_int = addr
            
        # Check if it's a dummy/placeholder address
        dummy_patterns = [
            0x41414141,  # AAAA
            0x42424242,  # BBBB
            0x43434343,  # CCCC
            0x44444444,  # DDDD
            0xdeadbeef,
            0xcafebabe,
            0xdeadc0de,
            0xbaadf00d,
            0xfeedface
        ]
        
        if addr_int in dummy_patterns:
            return False
            
        # Check for other common dummy address patterns
        if (addr_int & 0xFFFF0000) == 0x41410000:  # AA??
            return False
        if (addr_int & 0xFFFF0000) == 0x42420000:  # BB??
            return False
            
        # Check that the address is in a valid memory region (text section of binary or library)
        if addr_int < 0x1000:
            return False  # Too low to be a valid address
            
        # Additional checks could be added here
        
        return True

    def find_jmp_esp_gadget(self) -> Optional[str]:
        """
        Find a 'jmp esp' or equivalent gadget that can be used to jump to shellcode.
        
        Returns:
            Hex string address of the gadget if found, None otherwise
        """
        # Try direct jmp esp (most reliable)
        jmp_esp = self.get_real_gadget_address("jmp esp")
        if jmp_esp:
            return jmp_esp
            
        # Try call esp (also reliable)
        call_esp = self.get_real_gadget_address("call esp")
        if call_esp:
            return call_esp
            
        # Try jmp eax after a gadget that moves esp to eax
        mov_eax_esp = self.get_real_gadget_address("mov eax, esp")
        if mov_eax_esp:
            jmp_eax = self.get_real_gadget_address("jmp eax")
            if jmp_eax:
                self.logger.info(f"Found alternative to jmp esp: mov eax, esp; jmp eax gadgets")
                return f"mov_eax_esp: {mov_eax_esp}, jmp_eax: {jmp_eax}"
        
        # Try push esp; ret (can work in some cases)
        push_esp_ret = self.get_real_gadget_address("push esp; ret")
        if push_esp_ret:
            return push_esp_ret
            
        # Try looking in libraries if ASLR is disabled
        security_features = self.state.get("security_features", {})
        if not security_features.get("pie", True) and not security_features.get("aslr", True):
            # Try in common libraries like libc
            jmp_esp_libc = self.get_real_gadget_address("jmp esp", "libc")
            if jmp_esp_libc:
                return jmp_esp_libc
                
            call_esp_libc = self.get_real_gadget_address("call esp", "libc")
            if call_esp_libc:
                return call_esp_libc
        
        # Nothing found
        return None

    def find_useful_gadgets(self) -> Dict[str, str]:
        """
        Find a collection of useful gadgets for exploitation.
        
        Returns:
            Dictionary mapping gadget descriptions to their addresses
        """
        arch = self.state.get("architecture", {}).get("arch", "x86")
        bits = self.state.get("architecture", {}).get("bits", 32)
        
        gadgets = {}
        
        # Find jmp esp or equivalent
        jmp_esp = self.find_jmp_esp_gadget()
        if jmp_esp:
            gadgets["jmp_esp"] = jmp_esp
        
        # Architecture-specific gadgets
        if arch == "x86" and bits == 32:
            # 32-bit x86 specific gadgets
            for pattern in ["pop eax; ret", "pop ebx; ret", "pop ecx; ret", "pop edx; ret", 
                           "xor eax, eax; ret", "int 0x80; ret", "pop ebp; ret"]:
                addr = self.get_real_gadget_address(pattern)
                if addr:
                    gadgets[pattern.replace("; ", "_").replace(" ", "_")] = addr
            
        elif arch == "x86" and bits == 64:
            # 64-bit x86_64 specific gadgets
            for pattern in ["pop rdi; ret", "pop rsi; ret", "pop rdx; ret", "pop rax; ret",
                           "syscall; ret", "pop rsp; ret", "pop rbp; ret"]:
                addr = self.get_real_gadget_address(pattern)
                if addr:
                    gadgets[pattern.replace("; ", "_").replace(" ", "_")] = addr
        
        # Check for system, execve, etc. in PLT
        if self.gdb.elf:
            for func in ["system", "execve", "open", "read", "write"]:
                if func in self.gdb.elf.plt:
                    gadgets[f"plt_{func}"] = hex(self.gdb.elf.plt[func])
        
        return gadgets
        
    def update_exploit_prompt_with_gadgets(self, prompt: str) -> str:
        """
        Update the exploit development prompt with useful gadgets.
        
        Args:
            prompt: Original prompt
            
        Returns:
            Updated prompt with gadget information
        """
        useful_gadgets = self.find_useful_gadgets()
        
        if not useful_gadgets:
            return prompt
            
        # Create a section about useful gadgets
        gadgets_section = "\n## USEFUL GADGETS FOR RELIABLE EXPLOITATION\n"
        
        # First highlight the jmp_esp gadget if available
        if "jmp_esp" in useful_gadgets:
            gadgets_section += f"- jmp esp gadget: {useful_gadgets['jmp_esp']} (use this to jump to shellcode)\n"
            gadgets_section += "  Usage example: `payload = b'A'*offset + p32(jmp_esp_addr) + shellcode`\n\n"
        
        # Add other gadgets
        gadgets_section += "Other useful gadgets:\n"
        for desc, addr in useful_gadgets.items():
            if desc != "jmp_esp":  # Skip jmp_esp as it's already highlighted
                # Convert the gadget name back to a readable format
                readable_desc = desc.replace("_", " ").replace("pop ", "pop ").replace("ret", "; ret")
                gadgets_section += f"- {readable_desc}: {addr}\n"
        
        # If we found PLT entries, highlight them
        plt_entries = {k: v for k, v in useful_gadgets.items() if k.startswith("plt_")}
        if plt_entries:
            gadgets_section += "\nPLT entries:\n"
            for desc, addr in plt_entries.items():
                func = desc.split("_")[1]
                gadgets_section += f"- {func}(): {addr}\n"
        
        # Add the section to the prompt
        if "## BINARY INFORMATION" in prompt:
            prompt = prompt.replace("## BINARY INFORMATION", gadgets_section + "\n## BINARY INFORMATION")
        else:
            prompt += "\n" + gadgets_section
            
        return prompt